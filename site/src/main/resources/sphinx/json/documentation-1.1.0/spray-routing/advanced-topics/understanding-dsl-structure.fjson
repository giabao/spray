{"body": "<div class=\"section\" id=\"understanding-the-dsl-structure\">\n<h1>Understanding the DSL Structure</h1>\n<p><em>spray-routing&#8217;s</em> rather compact route building DSL with its extensive use of function literals can initially appear tricky,\nespecially for users without a lot of Scala experience, so in this chapter we are explaining the mechanics in some more\ndetail.</p>\n<p>Assume you have the following route:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">route</span><span class=\"k\">:</span> <span class=\"kt\">Route</span> <span class=\"o\">=</span> <span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"s\">&quot;yeah&quot;</span><span class=\"o\">)</span>\n</pre></div>\n</div>\n<p>This is equivalent to:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">route</span><span class=\"k\">:</span> <span class=\"kt\">Route</span> <span class=\"o\">=</span> <span class=\"k\">_</span><span class=\"o\">.</span><span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"s\">&quot;yeah&quot;</span><span class=\"o\">)</span>\n</pre></div>\n</div>\n<p>which is itself the same as:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">route</span><span class=\"k\">:</span> <span class=\"kt\">Route</span> <span class=\"o\">=</span> <span class=\"o\">{</span> <span class=\"n\">ctx</span> <span class=\"k\">=&gt;</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"s\">&quot;yeah&quot;</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>which is a function literal. The function defined by the literal is created at the time the <tt class=\"docutils literal\"><span class=\"pre\">val</span></tt> statement is reached\nbut the code inside of the function is not executed until an actual request is injected into the route structure.\nThis is all probably quite clear.</p>\n<p>Now let&#8217;s look at this slightly more complex structure:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">route</span><span class=\"k\">:</span> <span class=\"kt\">Route</span> <span class=\"o\">=</span>\n  <span class=\"n\">get</span> <span class=\"o\">{</span>\n    <span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"s\">&quot;yeah&quot;</span><span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>This is equivalent to:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">route</span><span class=\"k\">:</span> <span class=\"kt\">Route</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">val</span> <span class=\"n\">inner</span> <span class=\"k\">=</span> <span class=\"o\">{</span> <span class=\"n\">ctx</span> <span class=\"k\">=&gt;</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"s\">&quot;yeah&quot;</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n  <span class=\"n\">get</span><span class=\"o\">.</span><span class=\"n\">apply</span><span class=\"o\">(</span><span class=\"n\">inner</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>All that the <a class=\"reference internal\" href=\"../../route-directives/complete/#complete\"><em>complete</em></a> directive is doing is creating a function instance, which is then passed to the apply\nmethod of the object named &#8220;<a class=\"reference internal\" href=\"../../method-directives/get/#get\"><em>get</em></a> directive&#8221;, which wraps its argument route (the inner route\nof the <tt class=\"docutils literal\"><span class=\"pre\">get</span></tt> directive) with some filter logic and produces the final route.</p>\n<p>Now let&#8217;s look at this code:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">route</span><span class=\"k\">:</span> <span class=\"kt\">Route</span> <span class=\"o\">=</span> <span class=\"n\">get</span> <span class=\"o\">{</span>\n  <span class=\"n\">println</span><span class=\"o\">(</span><span class=\"s\">&quot;MARK&quot;</span><span class=\"o\">)</span>\n  <span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"s\">&quot;yeah&quot;</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>This is equivalent to:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">route</span><span class=\"k\">:</span> <span class=\"kt\">Route</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">val</span> <span class=\"n\">inner</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n    <span class=\"n\">println</span><span class=\"o\">(</span><span class=\"s\">&quot;MARK&quot;</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span> <span class=\"n\">ctx</span> <span class=\"k\">=&gt;</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"s\">&quot;yeah&quot;</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n  <span class=\"n\">get</span><span class=\"o\">.</span><span class=\"n\">apply</span><span class=\"o\">(</span><span class=\"n\">inner</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>As you can see from this different representation of the same code the <tt class=\"docutils literal\"><span class=\"pre\">println</span></tt> statement is executed when the route\nval is <em>created</em>, not when a request comes in and the route is <em>executed</em>! In order to execute the <tt class=\"docutils literal\"><span class=\"pre\">println</span></tt> at\nrequest processing time it must be <em>inside</em> of the leaf-level <a class=\"reference internal\" href=\"../../route-directives/complete/#complete\"><em>complete</em></a> directive:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">route</span><span class=\"k\">:</span> <span class=\"kt\">Route</span> <span class=\"o\">=</span> <span class=\"n\">get</span> <span class=\"o\">{</span>\n  <span class=\"n\">complete</span> <span class=\"o\">{</span>\n    <span class=\"n\">println</span><span class=\"o\">(</span><span class=\"s\">&quot;MARK&quot;</span><span class=\"o\">)</span>\n    <span class=\"s\">&quot;yeah&quot;</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>The mistake of putting custom logic inside of the route structure, but <em>outside</em> of a leaf-level route, and expecting\nit to be executed at request-handling time, is probably the most frequent error seen by new <em>spray</em> users.</p>\n<div class=\"section\" id=\"understanding-extractions\">\n<h2>Understanding Extractions</h2>\n<p>In the examples above there are essentially two &#8220;areas&#8221; of code that are executed at different times:</p>\n<ul class=\"simple\">\n<li>code that runs at route construction time, so usually only once</li>\n<li>code that runs at request-handling time, so for every request anew</li>\n</ul>\n<p>If a route structure contains extractions there is one more &#8220;area&#8221; coming into play.\nLet&#8217;s take a look at this example:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">route</span><span class=\"k\">:</span> <span class=\"kt\">Route</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"n\">println</span><span class=\"o\">(</span><span class=\"s\">&quot;MARK 1&quot;</span><span class=\"o\">)</span>\n  <span class=\"n\">get</span> <span class=\"o\">{</span>\n    <span class=\"n\">println</span><span class=\"o\">(</span><span class=\"s\">&quot;MARK 2&quot;</span><span class=\"o\">)</span>\n    <span class=\"n\">path</span><span class=\"o\">(</span><span class=\"s\">&quot;abc&quot;</span> <span class=\"o\">/</span> <span class=\"nc\">Segment</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"k\">=&gt;</span>\n      <span class=\"n\">println</span><span class=\"o\">(</span><span class=\"s\">&quot;MARK 3&quot;</span><span class=\"o\">)</span>   <span class=\"c1\">//</span>\n      <span class=\"n\">complete</span> <span class=\"o\">{</span>          <span class=\"c1\">// code &quot;inside&quot;</span>\n        <span class=\"n\">println</span><span class=\"o\">(</span><span class=\"s\">&quot;MARK 4&quot;</span><span class=\"o\">)</span> <span class=\"c1\">// of the</span>\n        <span class=\"s\">&quot;yeah&quot;</span>            <span class=\"c1\">// extraction</span>\n      <span class=\"o\">}</span>                   <span class=\"c1\">//</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>Here we have put logging statements at four different places in our route structure. Let&#8217;s see when exactly they\nwill be executed.</p>\n<dl class=\"docutils\">\n<dt>MARK 1 and MARK 2</dt>\n<dd>From the analysis in the section above you should be able to see that there is no real difference between the &#8220;MARK 1&#8221;\nand &#8220;MARK 2&#8221; statements. They are both executed exactly once, when the route is built.</dd>\n<dt>MARK 3</dt>\n<dd>This statement lies within a function literal of an extraction, but outside of the leaf-level route. It is executed\nwhen the request is handled, so essentially shortly before the &#8220;MARK 4&#8221; statement.</dd>\n<dt>MARK 4</dt>\n<dd>This statement lives inside of the leaf-level route. As such it is executed anew for every request hitting its route.</dd>\n</dl>\n<p>Why is the &#8220;MARK 3&#8221; statement executed for every request, even though it doesn&#8217;t live at the leaf level?\nBecause it lives &#8220;underneath an extraction&#8221;. All branches of the route structure that lie inside of a function literal\nfor an extraction can only be created when the extracted values have been determined. Since the value of the\n<tt class=\"docutils literal\"><span class=\"pre\">Segment</span></tt> in the example above can only be known after a request has come in and its path has been parsed the\nbranch of the route structure &#8220;inside&#8221; of the extraction can only be built at request-handling time.</p>\n<p>So essentially the sequence of events in the example above is as follows:</p>\n<ol class=\"arabic simple\">\n<li>When the <tt class=\"docutils literal\"><span class=\"pre\">val</span> <span class=\"pre\">route</span> <span class=\"pre\">=</span> <span class=\"pre\">...</span></tt> declaration is executed the outer route structure is built.\nThe &#8220;outer route structure&#8221; consists of the <tt class=\"docutils literal\"><span class=\"pre\">get</span></tt> directive and its direct children, in this case only the <tt class=\"docutils literal\"><span class=\"pre\">path</span></tt>\ndirective.</li>\n<li>When a GET request with a matching URI comes in it flows through the outer route structure up until the point the\n<tt class=\"docutils literal\"><span class=\"pre\">path</span></tt> directive has extracted the value of the <tt class=\"docutils literal\"><span class=\"pre\">Segment</span></tt> placeholder.</li>\n<li>The extraction function literal is executed, with the extracted <tt class=\"docutils literal\"><span class=\"pre\">Segment</span></tt> value as argument. This function\ncreates the underlying route structure inside of the extraction.</li>\n<li>After the inner route structure has been created the request is injected into it. So the inner route structure\nunderneath an extraction is being &#8220;executed&#8221; right after its creation.</li>\n</ol>\n<p>Since the route structure inside of an extraction is fully dynamic it might look completely different depending on the\nvalue that has been extracted. In order to keep your route structure readable (and thus maintainable) you probably\nshouldn&#8217;t go too crazy with regard to dynamically creating complex route structures depending on specific extraction\nvalues though. However, understanding why it&#8217;d be possible is helpful in getting the most out of the <em>spray-routing</em>\nDSL.</p>\n</div>\n<div class=\"section\" id=\"performance-tuning\">\n<h2>Performance Tuning</h2>\n<p>With the understanding of the above sections it should now be possible to discover optimization potential in your route\nstructures for the (rare!) cases, where route execution performance really turns out to be a significant factor in your\napplication.</p>\n<p>Let&#8217;s compare two route structures that are almost equivalent with regard to how they respond to requests:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">routeA</span> <span class=\"k\">=</span>\n  <span class=\"n\">path</span><span class=\"o\">(</span><span class=\"s\">&quot;abc&quot;</span> <span class=\"o\">/</span> <span class=\"nc\">Segment</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"k\">=&gt;</span>\n    <span class=\"n\">get</span> <span class=\"o\">{</span>\n      <span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"n\">responseFor</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">))</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n\n<span class=\"k\">val</span> <span class=\"n\">routeB</span> <span class=\"k\">=</span>\n  <span class=\"n\">get</span> <span class=\"o\">{</span>\n    <span class=\"n\">path</span><span class=\"o\">(</span><span class=\"s\">&quot;abc&quot;</span> <span class=\"o\">/</span> <span class=\"nc\">Segment</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"k\">=&gt;</span>\n      <span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"n\">responseFor</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">))</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>The only difference between <tt class=\"docutils literal\"><span class=\"pre\">routeA</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">routeB</span></tt> is the order in which the <tt class=\"docutils literal\"><span class=\"pre\">get</span></tt> and the <tt class=\"docutils literal\"><span class=\"pre\">path</span></tt> directive are\nnested. <tt class=\"docutils literal\"><span class=\"pre\">routeB</span></tt> will be a tiny amount faster in responding to requests, because the dynamic part of the route\nstructure, i.e. the one that is rebuilt anew for every request, is smaller.</p>\n<p>A general recommendation could therefore be to &#8220;pull up&#8221; directives without extractions as far as possible and only\nstart extracting values at the lower levels of your routing tree. However, in the grand majority of applications we&#8217;d\nexpect the benefits of a cleanly and logically laid out structure to far outweigh potential performance improvements\nthrough a more complex solution that goes out of its way to push down or even avoid extractions for a tiny,\nnon-perceivable bump in performance.</p>\n</div>\n</div>\n", "display_toc": true, "title": "Understanding the DSL Structure", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-routing/advanced-topics/understanding-dsl-structure", "next": {"link": "../case-class-extraction/", "title": "Case Class Extraction"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-routing/advanced-topics/case-class-extraction", "Case Class Extraction", "N", "next"], ["documentation/spray-routing/advanced-topics/index", "Advanced Topics", "P", "previous"]], "meta": {}, "parents": [{"link": "../../../", "title": "Documentation"}, {"link": "../../", "title": "spray-routing"}, {"link": "../", "title": "Advanced Topics"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Understanding the DSL Structure</a><ul>\n<li><a class=\"reference internal\" href=\"#understanding-extractions\">Understanding Extractions</a></li>\n<li><a class=\"reference internal\" href=\"#performance-tuning\">Performance Tuning</a></li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../", "title": "Advanced Topics"}, "metatags": ""}