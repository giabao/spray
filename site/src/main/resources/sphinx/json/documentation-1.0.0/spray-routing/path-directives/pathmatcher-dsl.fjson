{"body": "<div class=\"section\" id=\"the-pathmatcher-dsl\">\n<span id=\"pathmatcher-dsl\"></span><h1>The PathMatcher DSL</h1>\n<p>For being able to work with the <a class=\"reference internal\" href=\"../#pathdirectives\"><em>PathDirectives</em></a> effectively you should have some understanding of the\n<tt class=\"docutils literal\"><span class=\"pre\">PathMatcher</span></tt> mini-DSL that <em>spray-routing</em> provides for elegantly defining URI matching behavior.</p>\n<div class=\"section\" id=\"overview\">\n<h2>Overview</h2>\n<p>When a request (or rather the respective <tt class=\"docutils literal\"><span class=\"pre\">RequestContext</span></tt> instance) enters the route structure it has an\n&#8220;unmatched path&#8221; that is identical to the <tt class=\"docutils literal\"><span class=\"pre\">request.uri.path</span></tt>. As it descends the routing tree and passes through one\nor more <a class=\"reference internal\" href=\"../pathPrefix/#pathprefix\"><em>pathPrefix</em></a>/<a class=\"reference internal\" href=\"../path/#path\"><em>path</em></a> directives the &#8220;unmatched path&#8221; progressively gets &#8220;eaten into&#8221; from the left\nuntil, in most cases, it eventually has been consumed completely.</p>\n<p>What exactly gets matched and consumed as well as extracted from the unmatched path in each directive is defined with\nthe patch matching DSL, which is built around these types:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">trait</span> <span class=\"nc\">PathMatcher</span><span class=\"o\">[</span><span class=\"kt\">L</span> <span class=\"k\">&lt;:</span> <span class=\"kt\">HList</span><span class=\"o\">]</span>\n<span class=\"nc\">type</span> <span class=\"nc\">PathMatcher0</span> <span class=\"k\">=</span> <span class=\"nc\">PathMatcher</span><span class=\"o\">[</span><span class=\"kt\">HNil</span><span class=\"o\">]</span>\n<span class=\"k\">type</span> <span class=\"kt\">PathMatcher1</span><span class=\"o\">[</span><span class=\"kt\">T</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"nc\">PathMatcher</span><span class=\"o\">[</span><span class=\"kt\">T</span> <span class=\"kt\">::</span> <span class=\"kt\">HNil</span><span class=\"o\">]</span>\n</pre></div>\n</div>\n<p>The number and types of the values extracted by a <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher</span></tt> instance is represented by the <tt class=\"docutils literal\"><span class=\"pre\">L</span> <span class=\"pre\">&lt;:</span> <span class=\"pre\">HList</span></tt> type\nparameter. The convenience alias <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher0</span></tt> can be used for all matchers which don&#8217;t extract anything while\n<tt class=\"docutils literal\"><span class=\"pre\">PathMatcher1[T]</span></tt> defines a matcher which only extracts a single value of type <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt>.</p>\n<p>Here is an example of a more complex <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher</span></tt> expression:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">matcher</span><span class=\"k\">:</span> <span class=\"kt\">PathMatcher1</span><span class=\"o\">[</span><span class=\"kt\">Option</span><span class=\"o\">[</span><span class=\"kt\">Int</span><span class=\"o\">]]</span> <span class=\"k\">=</span>\n  <span class=\"s\">&quot;foo&quot;</span> <span class=\"o\">/</span> <span class=\"s\">&quot;bar&quot;</span> <span class=\"o\">/</span> <span class=\"s\">&quot;X&quot;</span> <span class=\"o\">~</span> <span class=\"nc\">IntNumber</span><span class=\"o\">.?</span> <span class=\"o\">/</span> <span class=\"o\">(</span><span class=\"s\">&quot;edit&quot;</span> <span class=\"o\">|</span> <span class=\"s\">&quot;create&quot;</span><span class=\"o\">)</span>\n</pre></div>\n</div>\n<p>This will match paths like <tt class=\"docutils literal\"><span class=\"pre\">foo/bar/X42/edit</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">foo/bar/X/create</span></tt>.</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">The path matching DSL describes what paths to accept <strong>after</strong> URL decoding. This is why the path-separating\nslashes have special status and cannot simply be specified as part of a string! The string &#8220;foo/bar&#8221; would match\nthe raw URI path &#8220;foo%2Fbar&#8221;, which is most likely not what you want!</p>\n</div>\n</div>\n<div class=\"section\" id=\"basic-pathmatchers\">\n<h2>Basic PathMatchers</h2>\n<p>A complex <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher</span></tt> can be constructed by combining or modifying more basic ones. Here are the basic matchers\nthat <em>spray-routing</em> already provides for you:</p>\n<dl class=\"docutils\">\n<dt><tt class=\"docutils literal\"><span class=\"pre\">String</span></tt></dt>\n<dd>You can use a <tt class=\"docutils literal\"><span class=\"pre\">String</span></tt> instance as a <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher0</span></tt>. Strings simply match themselves and extract no value.\nNote that strings are interpreted as the decoded representation of the path, so if they include a &#8216;/&#8217; character\nthis character will match &#8220;%2F&#8221; in the encoded raw URI!</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">Regex</span></tt></dt>\n<dd>You can use a <tt class=\"docutils literal\"><span class=\"pre\">Regex</span></tt> instance as a <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher1[String]</span></tt>, which matches whatever the regex matches and extracts\none <tt class=\"docutils literal\"><span class=\"pre\">String</span></tt> value. A <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher</span></tt> created from a regular expression extracts either the complete match (if the\nregex doesn&#8217;t contain a capture group) or the capture group (if the regex contains exactly one capture group).\nIf the regex contains more than one capture group an <tt class=\"docutils literal\"><span class=\"pre\">IllegalArgumentException</span></tt> will be thrown.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">Map[String,</span> <span class=\"pre\">T]</span></tt></dt>\n<dd>You can use a <tt class=\"docutils literal\"><span class=\"pre\">Map[String,</span> <span class=\"pre\">T]</span></tt> instance as a <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher1[T]</span></tt>, which matches any of the keys and extracts the\nrespective map value for it.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">Slash:</span> <span class=\"pre\">PathMatcher0</span></tt></dt>\n<dd>Matches exactly one path-separating slash (<tt class=\"docutils literal\"><span class=\"pre\">/</span></tt>) character and extracts nothing.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">Segment:</span> <span class=\"pre\">PathMatcher1[String]</span></tt></dt>\n<dd>Matches if the unmatched path starts with a path segment (i.e. not a slash).\nIf so the path segment is extracted as a <tt class=\"docutils literal\"><span class=\"pre\">String</span></tt> instance.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">PathEnd:</span> <span class=\"pre\">PathMatcher0</span></tt></dt>\n<dd>Matches the very end of the path, similar to <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt> in regular expressions and extracts nothing.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">Rest:</span> <span class=\"pre\">PathMatcher1[String]</span></tt></dt>\n<dd>Matches and extracts the complete remaining unmatched part of the request&#8217;s URI path as an (encoded!) String.\nIf you need access to the remaining <em>decoded</em> elements of the path use <tt class=\"docutils literal\"><span class=\"pre\">RestPath</span></tt> instead.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">RestPath:</span> <span class=\"pre\">PathMatcher1[Path]</span></tt></dt>\n<dd>Matches and extracts the complete remaining, unmatched part of the request&#8217;s URI path.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">IntNumber:</span> <span class=\"pre\">PathMatcher1[Int]</span></tt></dt>\n<dd>Efficiently matches a number of decimal digits and extracts their (non-negative) <tt class=\"docutils literal\"><span class=\"pre\">Int</span></tt> value. The matcher will not\nmatch zero digits or a sequence of digits that would represent an <tt class=\"docutils literal\"><span class=\"pre\">Int</span></tt> value larger than <tt class=\"docutils literal\"><span class=\"pre\">Int.MaxValue</span></tt>.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">LongNumber:</span> <span class=\"pre\">PathMatcher1[Long]</span></tt></dt>\n<dd>Efficiently matches a number of decimal digits and extracts their (non-negative) <tt class=\"docutils literal\"><span class=\"pre\">Long</span></tt> value. The matcher will not\nmatch zero digits or a sequence of digits that would represent an <tt class=\"docutils literal\"><span class=\"pre\">Long</span></tt> value larger than <tt class=\"docutils literal\"><span class=\"pre\">Long.MaxValue</span></tt>.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">HexIntNumber:</span> <span class=\"pre\">PathMatcher1[Int]</span></tt></dt>\n<dd>Efficiently matches a number of hex digits and extracts their (non-negative) <tt class=\"docutils literal\"><span class=\"pre\">Int</span></tt> value. The matcher will not match\nzero digits or a sequence of digits that would represent an <tt class=\"docutils literal\"><span class=\"pre\">Int</span></tt> value larger than <tt class=\"docutils literal\"><span class=\"pre\">Int.MaxValue</span></tt>.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">HexLongNumber:</span> <span class=\"pre\">PathMatcher1[Long]</span></tt></dt>\n<dd>Efficiently matches a number of hex digits and extracts their (non-negative) <tt class=\"docutils literal\"><span class=\"pre\">Long</span></tt> value. The matcher will not\nmatch zero digits or a sequence of digits that would represent an <tt class=\"docutils literal\"><span class=\"pre\">Long</span></tt> value larger than <tt class=\"docutils literal\"><span class=\"pre\">Long.MaxValue</span></tt>.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">DoubleNumber:</span> <span class=\"pre\">PathMatcher1[Double]</span></tt></dt>\n<dd>Matches and extracts a <tt class=\"docutils literal\"><span class=\"pre\">Double</span></tt> value. The matched string representation is the pure decimal,\noptionally signed form of a double value, i.e. without exponent.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">JavaUUID:</span> <span class=\"pre\">PathMatcher1[UUID]</span></tt></dt>\n<dd>Matches and extracts a <tt class=\"docutils literal\"><span class=\"pre\">java.util.UUID</span></tt> instance.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">Neutral:</span> <span class=\"pre\">PathMatcher0</span></tt></dt>\n<dd>A matcher that always matches, doesn&#8217;t consume anything and extracts nothing.\nServes mainly as a neutral element in <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher</span></tt> composition.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">Segments:</span> <span class=\"pre\">PathMatcher1[List[String]]</span></tt></dt>\n<dd>Matches all remaining segments as a list of strings. Note that this can also be &#8220;no segments&#8221; resulting in the empty\nlist. If the path has a trailing slash this slash will <em>not</em> be matched, i.e. remain unmatched and to be consumed by\npotentially nested directives.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">separateOnSlashes(string:</span> <span class=\"pre\">String):</span> <span class=\"pre\">PathMatcher0</span></tt></dt>\n<dd>Converts a path string containing slashes into a <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher0</span></tt> that interprets slashes as\npath segment separators. This means that a matcher matching &#8220;%2F&#8221; cannot be constructed with this helper.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">provide[L</span> <span class=\"pre\">&lt;:</span> <span class=\"pre\">HList](extractions:</span> <span class=\"pre\">L):</span> <span class=\"pre\">PathMatcher[L]</span></tt></dt>\n<dd>Always matches, consumes nothing and extracts the given <tt class=\"docutils literal\"><span class=\"pre\">HList</span></tt> of values.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher[L</span> <span class=\"pre\">&lt;:</span> <span class=\"pre\">HList](prefix:</span> <span class=\"pre\">Path,</span> <span class=\"pre\">extractions:</span> <span class=\"pre\">L):</span> <span class=\"pre\">PathMatcher[L]</span></tt></dt>\n<dd>Matches and consumes the given path prefix and extracts the given list of extractions.\nIf the given prefix is empty the returned matcher matches always and consumes nothing.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"combinators\">\n<h2>Combinators</h2>\n<p>Path matchers can be combined with these combinators to form higher-level constructs:</p>\n<dl class=\"docutils\">\n<dt>Tilde Operator (<tt class=\"docutils literal\"><span class=\"pre\">~</span></tt>)</dt>\n<dd>The tilde is the most basic combinator. It simply concatenates two matchers into one, i.e if the first one matched\n(and consumed) the second one is tried. The extractions of both matchers are combined type-safely.\nFor example: <tt class=\"docutils literal\"><span class=\"pre\">&quot;foo&quot;</span> <span class=\"pre\">~</span> <span class=\"pre\">&quot;bar&quot;</span></tt> yields a matcher that is identical to <tt class=\"docutils literal\"><span class=\"pre\">&quot;foobar&quot;</span></tt>.</dd>\n<dt>Slash Operator (<tt class=\"docutils literal\"><span class=\"pre\">/</span></tt>)</dt>\n<dd>This operator concatenates two matchers and inserts a <tt class=\"docutils literal\"><span class=\"pre\">Slash</span></tt> matcher in between them.\nFor example: <tt class=\"docutils literal\"><span class=\"pre\">&quot;foo&quot;</span> <span class=\"pre\">/</span> <span class=\"pre\">&quot;bar&quot;</span></tt> is identical to <tt class=\"docutils literal\"><span class=\"pre\">&quot;foo&quot;</span> <span class=\"pre\">~</span> <span class=\"pre\">Slash</span> <span class=\"pre\">~</span> <span class=\"pre\">&quot;bar&quot;</span></tt>.</dd>\n<dt>Pipe Operator (<tt class=\"docutils literal\"><span class=\"pre\">|</span></tt>)</dt>\n<dd>This operator combines two matcher alternatives in that the second one is only tried if the first one did <em>not</em> match.\nThe two sub-matchers must have compatible types.\nFor example: <tt class=\"docutils literal\"><span class=\"pre\">&quot;foo&quot;</span> <span class=\"pre\">|</span> <span class=\"pre\">&quot;bar&quot;</span></tt> will match either &#8220;foo&#8221; <em>or</em> &#8220;bar&#8221;.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"modifiers\">\n<h2>Modifiers</h2>\n<p>Path matcher instances can be transformed with these modifier methods:</p>\n<dl class=\"docutils\">\n<dt><tt class=\"docutils literal\"><span class=\"pre\">/</span></tt></dt>\n<dd>The slash operator cannot only be used as combinator for combining two matcher instances, it can also be used as\na postfix call. <tt class=\"docutils literal\"><span class=\"pre\">matcher</span> <span class=\"pre\">/</span></tt> is identical to <tt class=\"docutils literal\"><span class=\"pre\">matcher</span> <span class=\"pre\">~</span> <span class=\"pre\">Slash</span></tt> but shorter and easier to read.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">?</span></tt></dt>\n<dd><p class=\"first\">By postfixing a matcher with <tt class=\"docutils literal\"><span class=\"pre\">?</span></tt> you can turn any <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher</span></tt> into one that always matches, optionally consumes\nand potentially extracts an <tt class=\"docutils literal\"><span class=\"pre\">Option</span></tt> of the underlying matchers extraction. The result type depends on the type\nof the underlying matcher:</p>\n<table border=\"1\" class=\"table table-striped last docutils\">\n<colgroup>\n<col width=\"48%\" />\n<col width=\"52%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">If a <tt class=\"docutils literal\"><span class=\"pre\">matcher</span></tt> is of type</th>\n<th class=\"head\">then <tt class=\"docutils literal\"><span class=\"pre\">matcher.?</span></tt> is of type</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher0</span></tt></td>\n<td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher0</span></tt></td>\n</tr>\n<tr class=\"row-odd\"><td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher1[T]</span></tt></td>\n<td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher1[Option[T]</span></tt></td>\n</tr>\n<tr class=\"row-even\"><td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher[L</span> <span class=\"pre\">&lt;:</span> <span class=\"pre\">HList]</span></tt></td>\n<td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher[Option[L]]</span></tt></td>\n</tr>\n</tbody>\n</table>\n</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">repeat(separator:</span> <span class=\"pre\">PathMatcher0</span> <span class=\"pre\">=</span> <span class=\"pre\">PathMatchers.Neutral)</span></tt></dt>\n<dd><p class=\"first\">By postfixing a matcher with <tt class=\"docutils literal\"><span class=\"pre\">repeat(separator)</span></tt> you can turn any <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher</span></tt> into one that always matches,\nconsumes zero or more times (with the given separator) and potentially extracts a <tt class=\"docutils literal\"><span class=\"pre\">List</span></tt> of the underlying matcher&#8217;s\nextractions. The result type depends on the type of the underlying matcher:</p>\n<table border=\"1\" class=\"table table-striped last docutils\">\n<colgroup>\n<col width=\"41%\" />\n<col width=\"59%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">If a <tt class=\"docutils literal\"><span class=\"pre\">matcher</span></tt> is of type</th>\n<th class=\"head\">then <tt class=\"docutils literal\"><span class=\"pre\">matcher.repeat(...)</span></tt> is of type</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher0</span></tt></td>\n<td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher0</span></tt></td>\n</tr>\n<tr class=\"row-odd\"><td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher1[T]</span></tt></td>\n<td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher1[List[T]</span></tt></td>\n</tr>\n<tr class=\"row-even\"><td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher[L</span> <span class=\"pre\">&lt;:</span> <span class=\"pre\">HList]</span></tt></td>\n<td><tt class=\"docutils literal\"><span class=\"pre\">PathMatcher[List[L]]</span></tt></td>\n</tr>\n</tbody>\n</table>\n</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">unary_!</span></tt></dt>\n<dd>By prefixing a matcher with <tt class=\"docutils literal\"><span class=\"pre\">!</span></tt> it can be turned into a <tt class=\"docutils literal\"><span class=\"pre\">PathMatcher0</span></tt> that only matches if the underlying matcher\ndoes <em>not</em> match and vice versa.</dd>\n<dt><tt class=\"docutils literal\"><span class=\"pre\">transform</span></tt> / <tt class=\"docutils literal\"><span class=\"pre\">(h)flatMap</span></tt> / <tt class=\"docutils literal\"><span class=\"pre\">(h)map</span></tt></dt>\n<dd>These modifiers allow you to append your own &#8220;post-application&#8221; logic to another matcher in order to form a custom\none. You can map over the extraction(s), turn mismatches into matches or vice-versa or do anything else with the\nresults of the underlying matcher. Take a look at the method signatures and implementations for more guidance as to\nhow to use them.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"examples\">\n<h2>Examples</h2>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"c1\">// matches /foo/</span>\n<span class=\"n\">path</span><span class=\"o\">(</span><span class=\"s\">&quot;foo&quot;</span> <span class=\"o\">/)</span>\n\n<span class=\"c1\">// matches e.g. /foo/123 and extracts &quot;123&quot; as a String</span>\n<span class=\"n\">path</span><span class=\"o\">(</span><span class=\"s\">&quot;foo&quot;</span> <span class=\"o\">/</span> <span class=\"s\">&quot;&quot;&quot;\\d+&quot;&quot;&quot;</span><span class=\"o\">.</span><span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"c1\">// matches e.g. /foo/bar123 and extracts &quot;123&quot; as a String</span>\n<span class=\"n\">path</span><span class=\"o\">(</span><span class=\"s\">&quot;foo&quot;</span> <span class=\"o\">/</span> <span class=\"s\">&quot;&quot;&quot;bar(\\d+)&quot;&quot;&quot;</span><span class=\"o\">.</span><span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"c1\">// identical to `path(Segments)`</span>\n<span class=\"n\">path</span><span class=\"o\">(</span><span class=\"nc\">Segment</span><span class=\"o\">.</span><span class=\"n\">repeat</span><span class=\"o\">(</span><span class=\"n\">separator</span> <span class=\"k\">=</span> <span class=\"nc\">Slash</span><span class=\"o\">))</span>\n\n<span class=\"c1\">// matches e.g. /i42 or /hCAFE and extracts an Int</span>\n<span class=\"n\">path</span><span class=\"o\">(</span><span class=\"s\">&quot;i&quot;</span> <span class=\"o\">~</span> <span class=\"nc\">IntNumber</span> <span class=\"o\">|</span> <span class=\"s\">&quot;h&quot;</span> <span class=\"o\">~</span> <span class=\"nc\">HexIntNumber</span><span class=\"o\">)</span>\n\n<span class=\"c1\">// identical to path(&quot;foo&quot; ~ (PathEnd | Slash))</span>\n<span class=\"n\">path</span><span class=\"o\">(</span><span class=\"s\">&quot;foo&quot;</span> <span class=\"o\">~</span> <span class=\"nc\">Slash</span><span class=\"o\">.?)</span>\n\n<span class=\"c1\">// matches /red or /green or /blue and extracts 1, 2 or 3 respectively</span>\n<span class=\"n\">path</span><span class=\"o\">(</span><span class=\"nc\">Map</span><span class=\"o\">(</span><span class=\"s\">&quot;red&quot;</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"s\">&quot;green&quot;</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"s\">&quot;blue&quot;</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">3</span><span class=\"o\">))</span>\n\n<span class=\"c1\">// matches anything starting with &quot;/foo&quot; except for /foobar</span>\n<span class=\"n\">pathPrefix</span><span class=\"o\">(</span><span class=\"s\">&quot;foo&quot;</span> <span class=\"o\">~</span> <span class=\"o\">!</span><span class=\"s\">&quot;bar&quot;</span><span class=\"o\">)</span>\n</pre></div>\n</div>\n</div>\n</div>\n", "display_toc": true, "title": "The PathMatcher DSL", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-routing/path-directives/pathmatcher-dsl", "next": {"link": "../../respond-with-directives/", "title": "RespondWithDirectives"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-routing/respond-with-directives/index", "RespondWithDirectives", "N", "next"], ["documentation/spray-routing/path-directives/rawPathPrefixTest", "rawPathPrefixTest", "P", "previous"]], "meta": {}, "parents": [{"link": "../../../", "title": "Documentation"}, {"link": "../../", "title": "spray-routing"}, {"link": "../../predefined-directives-by-trait/", "title": "Predefined Directives (by trait)"}, {"link": "../", "title": "PathDirectives"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">The PathMatcher DSL</a><ul>\n<li><a class=\"reference internal\" href=\"#overview\">Overview</a></li>\n<li><a class=\"reference internal\" href=\"#basic-pathmatchers\">Basic PathMatchers</a></li>\n<li><a class=\"reference internal\" href=\"#combinators\">Combinators</a></li>\n<li><a class=\"reference internal\" href=\"#modifiers\">Modifiers</a></li>\n<li><a class=\"reference internal\" href=\"#examples\">Examples</a></li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../rawPathPrefixTest/", "title": "rawPathPrefixTest"}, "metatags": ""}